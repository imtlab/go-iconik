/*
 * iconik_users
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package users

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"fmt"

	"github.com/antihax/optional"
	"github.com/imtlab/go-iconik/shared"
)

const kSpec = "users/v1/"

// Linger please
var (
	_ context.Context
)

type DefaultApiService shared.Service

/*
DefaultApiService List groups info without details

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1GroupsBasicGetOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Which page number to fetch
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "Sort" (optional.String) -  A comma separated list of fieldnames with order. For example - first_name,asc;last_name,desc
     * @param "Alias" (optional.String) -  Filter by alias
     * @param "Description" (optional.String) -  Filter by descripton
     * @param "Name" (optional.String) -  Filter by name
     * @param "Roles" (optional.String) -  Filter by roles
     * @param "DateCreated" (optional.String) -  Filter by date_created
     * @param "DateModified" (optional.String) -  Filter by date_modified
     * @param "Query" (optional.String) -  Filter by any of first_name, last_name and email with wildcard support
     * @param "Ids" (optional.String) -  Filter list of id:s (comma separated)

@return GroupsSchema
*/

type DefaultApiV1GroupsBasicGetOpts struct {
	Page optional.Int32
	PerPage optional.Int32
	Sort optional.String
	Alias optional.String
	Description optional.String
	Name optional.String
	Roles optional.String
	DateCreated optional.String
	DateModified optional.String
	Query optional.String
	Ids optional.String
}

func (pService *DefaultApiService) V1GroupsBasicGet(ctx context.Context, localVarOptionals *DefaultApiV1GroupsBasicGetOpts) (GroupsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/basic/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", shared.ParameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", shared.ParameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Alias.IsSet() {
		localVarQueryParams.Add("alias", shared.ParameterToString(localVarOptionals.Alias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", shared.ParameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", shared.ParameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Roles.IsSet() {
		localVarQueryParams.Add("roles", shared.ParameterToString(localVarOptionals.Roles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreated.IsSet() {
		localVarQueryParams.Add("date_created", shared.ParameterToString(localVarOptionals.DateCreated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateModified.IsSet() {
		localVarQueryParams.Add("date_modified", shared.ParameterToString(localVarOptionals.DateModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", shared.ParameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ids.IsSet() {
		localVarQueryParams.Add("ids", shared.ParameterToString(localVarOptionals.Ids.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService List groups with details
 Required roles:  - can_read_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1GroupsGetOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Which page number to fetch
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "Sort" (optional.String) -  A comma separated list of fieldnames with order. For example - first_name,asc;last_name,desc
     * @param "Alias" (optional.String) -  Filter by alias
     * @param "Description" (optional.String) -  Filter by descripton
     * @param "Name" (optional.String) -  Filter by name
     * @param "Roles" (optional.String) -  Filter by roles
     * @param "DateCreated" (optional.String) -  Filter by date_created
     * @param "DateModified" (optional.String) -  Filter by date_modified
     * @param "Query" (optional.String) -  Filter by any of field with wildcard support
     * @param "Ids" (optional.String) -  Filter list of id:s (comma separated)

@return GroupsSchema
*/

type DefaultApiV1GroupsGetOpts struct {
	Page optional.Int32
	PerPage optional.Int32
	Sort optional.String
	Alias optional.String
	Description optional.String
	Name optional.String
	Roles optional.String
	DateCreated optional.String
	DateModified optional.String
	Query optional.String
	Ids optional.String
}

func (pService *DefaultApiService) V1GroupsGet(ctx context.Context, localVarOptionals *DefaultApiV1GroupsGetOpts) (GroupsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", shared.ParameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", shared.ParameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Alias.IsSet() {
		localVarQueryParams.Add("alias", shared.ParameterToString(localVarOptionals.Alias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", shared.ParameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", shared.ParameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Roles.IsSet() {
		localVarQueryParams.Add("roles", shared.ParameterToString(localVarOptionals.Roles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreated.IsSet() {
		localVarQueryParams.Add("date_created", shared.ParameterToString(localVarOptionals.DateCreated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateModified.IsSet() {
		localVarQueryParams.Add("date_modified", shared.ParameterToString(localVarOptionals.DateModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", shared.ParameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ids.IsSet() {
		localVarQueryParams.Add("ids", shared.ParameterToString(localVarOptionals.Ids.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular group by id
 Required roles:  - can_delete_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
*/
func (pService *DefaultApiService) V1GroupsGroupIdDelete(ctx context.Context, groupId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/", pService.Client.Cfg.BasePath, kSpec, groupId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular group by id
 Required roles:  - can_read_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId

@return GroupSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdGet(ctx context.Context, groupId string) (GroupSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/", pService.Client.Cfg.BasePath, kSpec, groupId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete group logo image.
 Required roles:  - can_write_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
*/
func (pService *DefaultApiService) V1GroupsGroupIdLogoDelete(ctx context.Context, groupId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/logo/", pService.Client.Cfg.BasePath, kSpec, groupId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Upload group logo image.
 Required roles:  - can_write_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param logo

@return InlineResponse200
*/
func (pService *DefaultApiService) V1GroupsGroupIdLogoPost(ctx context.Context, groupId string, logo string) (InlineResponse200, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse200
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/logo/", pService.Client.Cfg.BasePath, kSpec, groupId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	localVarFormParams.Add("logo", shared.ParameterToString(logo, ""))
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse200
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update group
 Required roles:  - can_write_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param body

@return GroupSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdPatch(ctx context.Context, groupId string, body GroupSchema) (GroupSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/", pService.Client.Cfg.BasePath, kSpec, groupId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update group
 Required roles:  - can_write_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param body

@return GroupSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdPut(ctx context.Context, groupId string, body GroupSchema) (GroupSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/", pService.Client.Cfg.BasePath, kSpec, groupId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Reindex a particular group by id
 Required roles:  - can_reindex_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId

@return UserSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdReindexPost(ctx context.Context, groupId string) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/reindex/", pService.Client.Cfg.BasePath, kSpec, groupId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a user from group
 Required roles:  - can_delete_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param userId

@return UserSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdUsersUserIdDelete(ctx context.Context, groupId string, userId string) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/users/%v/", pService.Client.Cfg.BasePath, kSpec, groupId, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Add user into a group
 Required roles:  - can_write_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param userId

@return UserSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdUsersUserIdPost(ctx context.Context, groupId string, userId string) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/users/%v/", pService.Client.Cfg.BasePath, kSpec, groupId, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Get all group mappings
 Required roles:  - can_read_group_mappings
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1GroupsMappingsGetOpts - Optional Parameters:
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "LastId" (optional.String) -

@return GroupMappingsSchema
*/

type DefaultApiV1GroupsMappingsGetOpts struct {
	PerPage optional.Int32
	LastId optional.String
}

func (pService *DefaultApiService) V1GroupsMappingsGet(ctx context.Context, localVarOptionals *DefaultApiV1GroupsMappingsGetOpts) (GroupMappingsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupMappingsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/mappings/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", shared.ParameterToString(localVarOptionals.LastId.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupMappingsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete group mapping by name
 Required roles:  - can_delete_group_mappings
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
*/
func (pService *DefaultApiService) V1GroupsMappingsNameDelete(ctx context.Context, name string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/mappings/%v/", pService.Client.Cfg.BasePath, kSpec, name)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Get a group mapping
 Required roles:  - can_read_group_mappings
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name

@return GroupMappingSchema
*/
func (pService *DefaultApiService) V1GroupsMappingsNameGet(ctx context.Context, name string) (GroupMappingSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupMappingSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/mappings/%v/", pService.Client.Cfg.BasePath, kSpec, name)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupMappingSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new group mapping
 Required roles:  - can_write_group_mappings
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return GroupMappingSchema
*/
func (pService *DefaultApiService) V1GroupsMappingsPost(ctx context.Context, body GroupMappingSchema) (GroupMappingSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupMappingSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/mappings/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v GroupMappingSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new group
 Required roles:  - can_write_groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return GroupSchema
*/
func (pService *DefaultApiService) V1GroupsPost(ctx context.Context, body GroupSchema) (GroupSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v GroupSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService List of users without details

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1UsersBasicGetOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Which page number to fetch
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "Sort" (optional.String) -  A comma separated list of fieldnames with order. For example - first_name,asc;last_name,desc
     * @param "DateCreated" (optional.String) -  Filter by date_created
     * @param "DateModified" (optional.String) -  Filter by date_modified
     * @param "Email" (optional.String) -  Filter by email
     * @param "FirstName" (optional.String) -  Filter by first_name
     * @param "LastName" (optional.String) -  Filter by last_name
     * @param "Groups" (optional.String) -  Filter by groups
     * @param "HideEmail" (optional.String) -  Filter by hide_email
     * @param "HidePhone" (optional.String) -  Filter by hide_phone
     * @param "IsAdmin" (optional.String) -  Filter by is_admin
     * @param "PasswordChanged" (optional.String) -  Filter by password_changed
     * @param "Phone" (optional.String) -  Filter by phone
     * @param "Photo" (optional.String) -  Filter by photo
     * @param "Status" (optional.String) -  Filter by status
     * @param "Query" (optional.String) -  Filter by any of first_name, last_name and email with wildcard support
     * @param "Ids" (optional.String) -  Filter list of id:s (comma separated)

@return UsersSchema
*/

type DefaultApiV1UsersBasicGetOpts struct {
	Page optional.Int32
	PerPage optional.Int32
	Sort optional.String
	DateCreated optional.String
	DateModified optional.String
	Email optional.String
	FirstName optional.String
	LastName optional.String
	Groups optional.String
	HideEmail optional.String
	HidePhone optional.String
	IsAdmin optional.String
	PasswordChanged optional.String
	Phone optional.String
	Photo optional.String
	Status optional.String
	Query optional.String
	Ids optional.String
}

func (pService *DefaultApiService) V1UsersBasicGet(ctx context.Context, localVarOptionals *DefaultApiV1UsersBasicGetOpts) (UsersSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UsersSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/basic/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", shared.ParameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", shared.ParameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreated.IsSet() {
		localVarQueryParams.Add("date_created", shared.ParameterToString(localVarOptionals.DateCreated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateModified.IsSet() {
		localVarQueryParams.Add("date_modified", shared.ParameterToString(localVarOptionals.DateModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarQueryParams.Add("email", shared.ParameterToString(localVarOptionals.Email.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstName.IsSet() {
		localVarQueryParams.Add("first_name", shared.ParameterToString(localVarOptionals.FirstName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastName.IsSet() {
		localVarQueryParams.Add("last_name", shared.ParameterToString(localVarOptionals.LastName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarQueryParams.Add("groups", shared.ParameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HideEmail.IsSet() {
		localVarQueryParams.Add("hide_email", shared.ParameterToString(localVarOptionals.HideEmail.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HidePhone.IsSet() {
		localVarQueryParams.Add("hide_phone", shared.ParameterToString(localVarOptionals.HidePhone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsAdmin.IsSet() {
		localVarQueryParams.Add("is_admin", shared.ParameterToString(localVarOptionals.IsAdmin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PasswordChanged.IsSet() {
		localVarQueryParams.Add("password_changed", shared.ParameterToString(localVarOptionals.PasswordChanged.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Phone.IsSet() {
		localVarQueryParams.Add("phone", shared.ParameterToString(localVarOptionals.Phone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Photo.IsSet() {
		localVarQueryParams.Add("photo", shared.ParameterToString(localVarOptionals.Photo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", shared.ParameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", shared.ParameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ids.IsSet() {
		localVarQueryParams.Add("ids", shared.ParameterToString(localVarOptionals.Ids.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UsersSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns current user

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersCurrentGet(ctx context.Context) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/current/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update user

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersCurrentPatch(ctx context.Context, body UserSchema) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/current/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete current user photo image.

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
*/
func (pService *DefaultApiService) V1UsersCurrentPhotoDelete(ctx context.Context) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/current/photo/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Upload current user photo image.

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param photo

@return InlineResponse2001
*/
func (pService *DefaultApiService) V1UsersCurrentPhotoPost(ctx context.Context, photo string) (InlineResponse2001, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2001
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/current/photo/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	localVarFormParams.Add("photo", shared.ParameterToString(photo, ""))
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2001
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update user

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersCurrentPut(ctx context.Context, body UserSchema) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/current/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns current user roles

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return UserRolesSchema
*/
func (pService *DefaultApiService) V1UsersCurrentRolesGet(ctx context.Context) (UserRolesSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserRolesSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/current/roles/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserRolesSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService List of users with details
 Required roles:  - can_read_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1UsersGetOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  Which page number to fetch
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "Sort" (optional.String) -  A comma separated list of fieldnames with order. For example - first_name,asc;last_name,desc
     * @param "DateCreated" (optional.String) -  Filter by date_created
     * @param "DateModified" (optional.String) -  Filter by date_modified
     * @param "Email" (optional.String) -  Filter by email
     * @param "FirstName" (optional.String) -  Filter by first_name
     * @param "LastName" (optional.String) -  Filter by last_name
     * @param "Groups" (optional.String) -  Filter by groups
     * @param "HideEmail" (optional.String) -  Filter by hide_email
     * @param "HidePhone" (optional.String) -  Filter by hide_phone
     * @param "IsAdmin" (optional.String) -  Filter by is_admin
     * @param "PasswordChanged" (optional.String) -  Filter by password_changed
     * @param "Phone" (optional.String) -  Filter by phone
     * @param "Photo" (optional.String) -  Filter by photo
     * @param "Status" (optional.String) -  Filter by status
     * @param "Query" (optional.String) -  Filter by any of first_name, last_name and email with wildcard support
     * @param "Ids" (optional.String) -  Filter list of id:s (comma separated)

@return UsersSchema
*/

type DefaultApiV1UsersGetOpts struct {
	Page optional.Int32
	PerPage optional.Int32
	Sort optional.String
	DateCreated optional.String
	DateModified optional.String
	Email optional.String
	FirstName optional.String
	LastName optional.String
	Groups optional.String
	HideEmail optional.String
	HidePhone optional.String
	IsAdmin optional.String
	PasswordChanged optional.String
	Phone optional.String
	Photo optional.String
	Status optional.String
	Query optional.String
	Ids optional.String
}

func (pService *DefaultApiService) V1UsersGet(ctx context.Context, localVarOptionals *DefaultApiV1UsersGetOpts) (UsersSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UsersSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", shared.ParameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", shared.ParameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreated.IsSet() {
		localVarQueryParams.Add("date_created", shared.ParameterToString(localVarOptionals.DateCreated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateModified.IsSet() {
		localVarQueryParams.Add("date_modified", shared.ParameterToString(localVarOptionals.DateModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarQueryParams.Add("email", shared.ParameterToString(localVarOptionals.Email.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstName.IsSet() {
		localVarQueryParams.Add("first_name", shared.ParameterToString(localVarOptionals.FirstName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastName.IsSet() {
		localVarQueryParams.Add("last_name", shared.ParameterToString(localVarOptionals.LastName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarQueryParams.Add("groups", shared.ParameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HideEmail.IsSet() {
		localVarQueryParams.Add("hide_email", shared.ParameterToString(localVarOptionals.HideEmail.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HidePhone.IsSet() {
		localVarQueryParams.Add("hide_phone", shared.ParameterToString(localVarOptionals.HidePhone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsAdmin.IsSet() {
		localVarQueryParams.Add("is_admin", shared.ParameterToString(localVarOptionals.IsAdmin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PasswordChanged.IsSet() {
		localVarQueryParams.Add("password_changed", shared.ParameterToString(localVarOptionals.PasswordChanged.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Phone.IsSet() {
		localVarQueryParams.Add("phone", shared.ParameterToString(localVarOptionals.Phone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Photo.IsSet() {
		localVarQueryParams.Add("photo", shared.ParameterToString(localVarOptionals.Photo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", shared.ParameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", shared.ParameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ids.IsSet() {
		localVarQueryParams.Add("ids", shared.ParameterToString(localVarOptionals.Ids.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UsersSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Login a user

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersLoginPost(ctx context.Context, body UserLoginSchema) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/login/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new user
 Required roles:  - can_create_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersPost(ctx context.Context, body UserSchema) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular user by id
 Required roles:  - can_delete_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
*/
func (pService *DefaultApiService) V1UsersUserIdDelete(ctx context.Context, userId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular user by id
 Required roles:  - can_read_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersUserIdGet(ctx context.Context, userId string) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update user
 Required roles:  - can_write_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param body

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersUserIdPatch(ctx context.Context, userId string, body UserSchema) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a photo image of a specified user.
 Required roles:  - can_write_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
*/
func (pService *DefaultApiService) V1UsersUserIdPhotoDelete(ctx context.Context, userId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/photo/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Upload user photo image.
 Required roles:  - can_write_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param photo

@return InlineResponse2001
*/
func (pService *DefaultApiService) V1UsersUserIdPhotoPost(ctx context.Context, userId string, photo string) (InlineResponse2001, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2001
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/photo/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	localVarFormParams.Add("photo", shared.ParameterToString(photo, ""))
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2001
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update user
 Required roles:  - can_write_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param body

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersUserIdPut(ctx context.Context, userId string, body UserSchema) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Reindex a particular user by id
 Required roles:  - can_reindex_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersUserIdReindexPost(ctx context.Context, userId string) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/reindex/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns user roles by user_id
 Required roles:  - can_read_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId

@return UserRolesSchema
*/
func (pService *DefaultApiService) V1UsersUserIdRolesGet(ctx context.Context, userId string) (UserRolesSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserRolesSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/roles/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserRolesSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns user roles by user_id
 Required roles:  - can_read_users
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param role
*/
func (pService *DefaultApiService) V1UsersUserIdRolesRoleGet(ctx context.Context, userId string, role string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/roles/%v/", pService.Client.Cfg.BasePath, kSpec, userId, role)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Remove a users SAML IdP setting

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersUserIdSamlDelete(ctx context.Context, userId string) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/saml/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update a users SAML IdP settings

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param body

@return UserSchema
*/
func (pService *DefaultApiService) V1UsersUserIdSamlPut(ctx context.Context, userId string, body UserSamlIdpUpdateSchema) (UserSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/saml/", pService.Client.Cfg.BasePath, kSpec, userId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
