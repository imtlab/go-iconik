/*
 * iconik_users_notifications
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package usersnotifications

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"fmt"

	"github.com/antihax/optional"
	"github.com/imtlab/iconik/shared"
)

const kSpec = "users-notifications/v1/"

// Linger please
var (
	_ context.Context
)

type DefaultApiService shared.Service

/*
DefaultApiService Returns a particular notification_setting by id
 Required roles:  - can_read_notification_settings
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1NotificationSettingsGetOpts - Optional Parameters:
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "LastId" (optional.String) -  ID of a last file set on previous page

@return NotificationSettingsSchema
*/

type DefaultApiV1NotificationSettingsGetOpts struct {
	PerPage optional.Int32
	LastId optional.String
}

func (pService *DefaultApiService) V1NotificationSettingsGet(ctx context.Context, localVarOptionals *DefaultApiV1NotificationSettingsGetOpts) (NotificationSettingsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NotificationSettingsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotification_settings/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", shared.ParameterToString(localVarOptionals.LastId.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v NotificationSettingsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular notification_setting by id
 Required roles:  - can_read_notification_settings
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param subObjectType
 * @param eventType
 * @param protocol

@return NotificationSettingSchema
*/
func (pService *DefaultApiService) V1NotificationSettingsObjectTypeSubObjectTypeEventTypeProtocolGet(ctx context.Context, objectType string, subObjectType string, eventType string, protocol string) (NotificationSettingSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NotificationSettingSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotification_settings/%v/%v/%v/%v/", pService.Client.Cfg.BasePath, kSpec, objectType, subObjectType, eventType, protocol)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v NotificationSettingSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new notification_setting

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param subObjectType
 * @param eventType
 * @param protocol
 * @param body

@return NotificationSettingSchema
*/
func (pService *DefaultApiService) V1NotificationSettingsObjectTypeSubObjectTypeEventTypeProtocolPut(ctx context.Context, objectType string, subObjectType string, eventType string, protocol string, body NotificationSettingSchema) (NotificationSettingSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NotificationSettingSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotification_settings/%v/%v/%v/%v/", pService.Client.Cfg.BasePath, kSpec, objectType, subObjectType, eventType, protocol)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v NotificationSettingSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update notification
 Required roles:  - can_read_notifications
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
*/
func (pService *DefaultApiService) V1NotificationsAllReadPut(ctx context.Context) (*http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotifications/all/read/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a list of notifications
 Required roles:  - can_read_notifications
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1NotificationsGetOpts - Optional Parameters:
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "LastId" (optional.String) -  ID of a last file set on previous page

@return NotificationsSchema
*/

type DefaultApiV1NotificationsGetOpts struct {
	PerPage optional.Int32
	LastId optional.String
}

func (pService *DefaultApiService) V1NotificationsGet(ctx context.Context, localVarOptionals *DefaultApiV1NotificationsGetOpts) (NotificationsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NotificationsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotifications/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", shared.ParameterToString(localVarOptionals.LastId.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v NotificationsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular notification by id
 Required roles:  - can_delete_notifications
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param notificationId
*/
func (pService *DefaultApiService) V1NotificationsNotificationIdDelete(ctx context.Context, notificationId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotifications/%v/", pService.Client.Cfg.BasePath, kSpec, notificationId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular notification by id
 Required roles:  - can_read_notifications
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param notificationId

@return NotificationSchema
*/
func (pService *DefaultApiService) V1NotificationsNotificationIdGet(ctx context.Context, notificationId string) (NotificationSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NotificationSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotifications/%v/", pService.Client.Cfg.BasePath, kSpec, notificationId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v NotificationSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new notification

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return NotificationSchema
*/
func (pService *DefaultApiService) V1NotificationsPost(ctx context.Context, body NotificationSchema) (NotificationSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NotificationSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotifications/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v NotificationSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new system notification

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return NotificationSchema
*/
func (pService *DefaultApiService) V1NotificationsSystemPost(ctx context.Context, body SystemNotificationSchema) (NotificationSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NotificationSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%snotifications/system/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v NotificationSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete all user subscriptions for a specific object_type and object_id
 Required roles:  - can_read_subscriptions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param objectId

@return SubscriptionSchema
*/
func (pService *DefaultApiService) V1ObjectTypeObjectIdSubscriptionsAllDelete(ctx context.Context, objectType string, objectId string) (SubscriptionSchema, *http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SubscriptionSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%s%v/%v/subscriptions/all/", pService.Client.Cfg.BasePath, kSpec, objectType, objectId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriptionSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns user subscriptions for a specific object_type and object_id
 Required roles:  - can_read_subscriptions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param objectId

@return SubscriptionsSchema
*/
func (pService *DefaultApiService) V1ObjectTypeObjectIdSubscriptionsGet(ctx context.Context, objectType string, objectId string) (SubscriptionsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SubscriptionsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%s%v/%v/subscriptions/", pService.Client.Cfg.BasePath, kSpec, objectType, objectId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriptionsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns all user subscriptions
 Required roles:  - can_read_subscriptions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return SubscriptionSchema
*/
func (pService *DefaultApiService) V1SubscriptionsGet(ctx context.Context) (SubscriptionSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SubscriptionSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssubscriptions/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriptionSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new subscription

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return SubscriptionSchema
*/
func (pService *DefaultApiService) V1SubscriptionsPost(ctx context.Context, body SubscriptionSchema) (SubscriptionSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SubscriptionSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssubscriptions/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v SubscriptionSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular subscription by id
 Required roles:  - can_write_subscriptions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subscriptionId
*/
func (pService *DefaultApiService) V1SubscriptionsSubscriptionIdDelete(ctx context.Context, subscriptionId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssubscriptions/%v/", pService.Client.Cfg.BasePath, kSpec, subscriptionId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular subscription by id
 Required roles:  - can_read_subscriptions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subscriptionId

@return SubscriptionSchema
*/
func (pService *DefaultApiService) V1SubscriptionsSubscriptionIdGet(ctx context.Context, subscriptionId string) (SubscriptionSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SubscriptionSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssubscriptions/%v/", pService.Client.Cfg.BasePath, kSpec, subscriptionId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriptionSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
