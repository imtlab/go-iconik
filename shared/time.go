/*
 * iconik_shared
 *
 * iconik client code shared by all API packages
 *
 * API version: 1.0
 */

package shared

import (
	"encoding/json"
//	"fmt"
	"time"
)

/*
This shared.Time custom type is needed because the iconik API is not consistent in how it serializes date/time
For example:
	POST search/v1/search/ returns format `2006-01-02T15:04:05.999999` in the date_created and date_modified fields of each SearchDocumentSchema object in SearchDocumentsSchema.objects
	...whereas...
	GET metadata/v1/{object_type}/categories/{name}/ returns format `2006-01-02T15:04:05.999999-07:00` in the date_created and date_created fields of MetadataCategorySchema

In the Go client code generated by swagger-codegen, the above corresponds to:
	search.DefaultApiService.V1SearchPost() returns format `2006-01-02T15:04:05.999999` in the DateCreated and DateModified fields of each 
	search.SearchDocumentSchema struct in search.SearchDocumentsSchema.Objects.
	...whereas...
	metadata.DefaultApiService.V1ObjectTypeCategoriesNameGet() returns format `2006-01-02T15:04:05.999999-07:00` in the DateCreated and DateModified fields
	of the metadata.MetadataCategorySchema struct.

So far I’ve encountered the 2 formatting patterns defined as constants below.
To accommodate either, shared.Time’s implementation of the Unmarshaler interface detects if the incoming serialized date/time string
ends with the pattern `-07:00` and selects the formatting pattern accordingly.

As for the Marshaler interface, I can’t possibly guess what the API expects and the API docs don’t specify it,
so I’ll stick with the default until I encounter a problem.  I’ve commented out shared.Time’s MarshalJSON() so
json.Marshal() will fall back on the underlying type’s (i.e., time.Time’s) MarshalJSON() which uses time.RFC3339
for its pattern (`2006-01-02T15:04:05Z07:00`).
ADDENDUM 2023-01-26:
	No, apparently it doesn't fall back on the underlying type’s MarshalJSON().  What's happening is it's marshaling as a struct.
	I have to explicitly implement Marshaler interface, possibly just calling the underlying type’s underlying type’s MarshalJSON().

ADDENDUM 2023-01-26:
I've also seen `2006-01-02 15:04:05`
So I'll probably have to use Regex to match the entire incoming pattern for selecting the formatting pattern.
My current quick and dirty method of looking for the colon at the third from last rune will match
both kFmtWithTZ and `2006-01-02 15:04:05`.
I haven't yet changed anything about this.
*/
const (
	kFmtWithTZ		= `2006-01-02T15:04:05.999999-07:00`
	kFmtWithoutTZ	= `2006-01-02T15:04:05.999999`
)

type Time time.Time

//	implement the json.Marshaler and json.Unmarshaler interfaces for type shared.Time
/*
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}

type Unmarshaler interface {
	UnmarshalJSON([]byte) error
}
*/

/*	Apparently when marshaling, the fields in a struct is not addressable, so the receiver can't be *Time.
	In order for a field selector in a struct to be addressable the struct operand must be addressable.
	Maybe under the hood json.Marshal creates a pointer to the struct being Marshaled,
	so none of that pointer's field selectors are addressable.
*/
func (dt Time) MarshalJSON() (xBytes []byte, err error) {
/*
//	fmt.Println(`@@@ ENTERED (shared.Time) MarshalJSON() @@@`)		//\\//	DEBUG
//	fmt.Printf("@@@ dt: \"%v\", %#[1]v, %+[1]v @@@\n", dt)			//\\//	DEBUG
	tt := time.Time(dt)
	str := tt.Format(kFmtWithTZ/ *time.RFC3339Nano* /)
//	fmt.Printf("@@@ str: \"%s\" @@@\n", str)						//\\//	DEBUG
	xBytes = []byte(`"` + str + `"`)	//	Okay, the secret is I have to include the quotes!
//	xBytes = []byte(`"` + time.Time(dt).Format(kFmtWithTZ/ *time.RFC3339Nano* /) + `"`)
	return
*/
//	I probably also could have just done...
	return time.Time(dt).MarshalJSON()
}


func (p *Time) UnmarshalJSON(xBytes []byte) (err error) {
//	fmt.Println(`@@@ ENTERED (*shared.Time) UnmarshalJSON() @@@`)	//\\//	DEBUG
	//	first unmarshal into a string, leaving it in its "serialized" form
	var val string
	if err = json.Unmarshal(xBytes, &val); nil == err {
		var pattern string
		//	detect if this serialized date time ends with pattern `-07:00`
		xRunes := []rune(val)
		if ':' == xRunes[len(xRunes)-3] {
			pattern = /*kFmtWithTZ*/time.RFC3339Nano
		} else {
			pattern = kFmtWithoutTZ
		}
//		fmt.Printf("@@@ pattern: \"%s\" @@@\n", pattern)			//\\//	DEBUG

		//	then parse the string using our custom format
		//	because of the need to cast, we can’t assign directly to *p
		var dt time.Time
		//	In the absence of time zone information, time.Parse() interprets a time as UTC, which is precisely what we want.
		if dt, err = time.Parse(pattern, val); nil == err {
//			fmt.Printf("@@@ PARSED as \"%v\" @@@\n", dt)			//\\//	DEBUG
			*p = Time(dt)
/*		} else {
			fmt.Println("@@@ ERROR:", err)							//\\//	DEBUG
*/
		}
	}

	return
}

//	implement the fmt.Stringer and fmt.GoStringer interfaces for type Time
/*
type Stringer interface {
	String() string
}

type GoStringer interface {
	GoString() string
}
*/

func (dt Time) String() string {
//	fmt.Println(`@@@ ENTERED (shared.Time) String() @@@`)			//\\//	DEBUG
//	return time.Time(dt).Format(kFmtWithTZ/*time.RFC3339Nano*/)

//	return fmt.Sprintf("%v", time.Time(dt))
	return time.Time(dt).String()
}

func (dt Time) GoString() string {
//	return fmt.Sprintf("%#v", time.Time(dt))
	return time.Time(dt).GoString()
}
