/*
 * iconik_acls
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package acls

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"fmt"

	"github.com/imtlab/iconik/shared"
)

const kSpec = "acls/v1/"

// Linger please
var (
	_ context.Context
)

type DefaultApiService shared.Service

/*
DefaultApiService Delete acls for content of multiple objects
 Required roles:  - can_delete_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param body
*/
func (pService *DefaultApiService) V1AclObjectTypeContentDelete(ctx context.Context, objectType string, body DeleteBulkAcLsSchema) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/content/", pService.Client.Cfg.BasePath, kSpec, objectType)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Create a new acl for content of multiple objects
 Required roles:  - can_write_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param body
*/
func (pService *DefaultApiService) V1AclObjectTypeContentPut(ctx context.Context, objectType string, body CreateBulkAcLsSchema) (*http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/content/", pService.Client.Cfg.BasePath, kSpec, objectType)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Delete acls for multiple objects
 Required roles:  - can_delete_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param body
*/
func (pService *DefaultApiService) V1AclObjectTypeDelete(ctx context.Context, objectType string, body DeleteAcLsSchema) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/", pService.Client.Cfg.BasePath, kSpec, objectType)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService List of object permissions
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param objectKey

@return AclSchema
*/
func (pService *DefaultApiService) V1AclObjectTypeObjectKeyGet(ctx context.Context, objectType string, objectKey string) (AclSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Check if particular object has required permission
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param objectKey
 * @param permission
*/
func (pService *DefaultApiService) V1AclObjectTypeObjectKeyPermissionGet(ctx context.Context, objectType string, objectKey string, permission string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/%v/%v/", pService.Client.Cfg.BasePath, kSpec, objectType, objectKey, permission)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService List of permissions for the user

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param objectKey

@return CombinedPermissionsSchema
*/
func (pService *DefaultApiService) V1AclObjectTypeObjectKeyPermissionsGet(ctx context.Context, objectType string, objectKey string) (CombinedPermissionsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CombinedPermissionsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/%v/permissions/", pService.Client.Cfg.BasePath, kSpec, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CombinedPermissionsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Check if objects have required permission
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param permission

@return BulkAclSchema
*/
func (pService *DefaultApiService) V1AclObjectTypePermissionPost(ctx context.Context, objectType string, permission string) (BulkAclSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BulkAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, objectType, permission)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v BulkAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v BulkAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new acl for multiple objects
 Required roles:  - can_write_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param body

@return CreateAcLsResultSchema
*/
func (pService *DefaultApiService) V1AclObjectTypePut(ctx context.Context, objectType string, body CreateAcLsSchema) (CreateAcLsResultSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CreateAcLsResultSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/%v/", pService.Client.Cfg.BasePath, kSpec, objectType)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CreateAcLsResultSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Check if objects have required permission
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return BulkAclSchema
*/
func (pService *DefaultApiService) V1AclPost(ctx context.Context) (BulkAclSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BulkAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v BulkAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 403 {
			var v BulkAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Retreive all acl templates
 Required roles:  - can_read_acl_templates
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return AclTemplatesSchema
*/
func (pService *DefaultApiService) V1AclTemplatesGet(ctx context.Context) (AclTemplatesSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AclTemplatesSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/templates/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AclTemplatesSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create an acl template
 Required roles:  - can_write_acl_templates
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return AclTemplateSchema
*/
func (pService *DefaultApiService) V1AclTemplatesPost(ctx context.Context, body AclTemplateSchema) (AclTemplateSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AclTemplateSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/templates/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v AclTemplateSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Remove an acl template
 Required roles:  - can_delete_acl_templates
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param templateId
*/
func (pService *DefaultApiService) V1AclTemplatesTemplateIdDelete(ctx context.Context, templateId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/templates/%v/", pService.Client.Cfg.BasePath, kSpec, templateId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Retreive an acl template
 Required roles:  - can_read_acl_templates
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param templateId

@return AclTemplateSchema
*/
func (pService *DefaultApiService) V1AclTemplatesTemplateIdGet(ctx context.Context, templateId string) (AclTemplateSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AclTemplateSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/templates/%v/", pService.Client.Cfg.BasePath, kSpec, templateId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AclTemplateSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Apply template permissions to an object

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param templateId
 * @param objectType
 * @param objectKey
*/
func (pService *DefaultApiService) V1AclTemplatesTemplateIdObjectTypeObjectKeyPost(ctx context.Context, templateId string, objectType string, objectKey string) (*http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/templates/%v/%v/%v/", pService.Client.Cfg.BasePath, kSpec, templateId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Update an acl template
 Required roles:  - can_write_acl_templates
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param templateId
 * @param body

@return AclTemplateSchema
*/
func (pService *DefaultApiService) V1AclTemplatesTemplateIdPatch(ctx context.Context, templateId string, body AclTemplateSchema) (AclTemplateSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AclTemplateSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/templates/%v/", pService.Client.Cfg.BasePath, kSpec, templateId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AclTemplateSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update an acl template
 Required roles:  - can_write_acl_templates
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param templateId
 * @param body

@return AclTemplateSchema
*/
func (pService *DefaultApiService) V1AclTemplatesTemplateIdPut(ctx context.Context, templateId string, body AclTemplateSchema) (AclTemplateSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AclTemplateSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sacl/templates/%v/", pService.Client.Cfg.BasePath, kSpec, templateId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AclTemplateSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular acl by id for an object
 Required roles:  - can_delete_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param objectType
 * @param objectKey
*/
func (pService *DefaultApiService) V1GroupsGroupIdAclObjectTypeObjectKeyDelete(ctx context.Context, groupId string, objectType string, objectKey string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, groupId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService List of groups permissions for an object
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param objectType
 * @param objectKey

@return GroupAclSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdAclObjectTypeObjectKeyGet(ctx context.Context, groupId string, objectType string, objectKey string) (GroupAclSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, groupId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Check if group has particular permission for an object
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param objectType
 * @param objectKey
 * @param permission
*/
func (pService *DefaultApiService) V1GroupsGroupIdAclObjectTypeObjectKeyPermissionGet(ctx context.Context, groupId string, objectType string, objectKey string, permission string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/acl/%v/%v/%v/", pService.Client.Cfg.BasePath, kSpec, groupId, objectType, objectKey, permission)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Update or create group acl for an object
 Required roles:  - can_write_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @param objectType
 * @param objectKey
 * @param body

@return GroupAclSchema
*/
func (pService *DefaultApiService) V1GroupsGroupIdAclObjectTypeObjectKeyPut(ctx context.Context, groupId string, objectType string, objectKey string, body GroupAclSchema) (GroupAclSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GroupAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sgroups/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, groupId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v GroupAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService List of share acls
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param objectKey

@return SharesAclSchema
*/
func (pService *DefaultApiService) V1SharesObjectTypeObjectKeyGet(ctx context.Context, objectType string, objectKey string) (SharesAclSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SharesAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sshares/%v/%v/", pService.Client.Cfg.BasePath, kSpec, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SharesAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a share acl for an object
 Required roles:  - can_delete_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shareId
 * @param objectType
 * @param objectKey
*/
func (pService *DefaultApiService) V1SharesShareIdAclObjectTypeObjectKeyDelete(ctx context.Context, shareId string, objectType string, objectKey string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sshares/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, shareId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService List of share permissions for an object
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shareId
 * @param objectType
 * @param objectKey

@return ShareAclSchema
*/
func (pService *DefaultApiService) V1SharesShareIdAclObjectTypeObjectKeyGet(ctx context.Context, shareId string, objectType string, objectKey string) (ShareAclSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ShareAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sshares/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, shareId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ShareAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns a share acl for an object
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shareId
 * @param objectType
 * @param objectKey
 * @param permission
*/
func (pService *DefaultApiService) V1SharesShareIdAclObjectTypeObjectKeyPermissionGet(ctx context.Context, shareId string, objectType string, objectKey string, permission string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sshares/%v/acl/%v/%v/%v/", pService.Client.Cfg.BasePath, kSpec, shareId, objectType, objectKey, permission)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Create a new share acl for an object
 Required roles:  - can_write_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shareId
 * @param objectType
 * @param objectKey
 * @param body

@return ShareAclSchema
*/
func (pService *DefaultApiService) V1SharesShareIdAclObjectTypeObjectKeyPost(ctx context.Context, shareId string, objectType string, objectKey string, body ShareAclSchema) (ShareAclSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ShareAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sshares/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, shareId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ShareAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update share acl for an object
 Required roles:  - can_write_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shareId
 * @param objectType
 * @param objectKey
 * @param body

@return ShareAclSchema
*/
func (pService *DefaultApiService) V1SharesShareIdAclObjectTypeObjectKeyPut(ctx context.Context, shareId string, objectType string, objectKey string, body ShareAclSchema) (ShareAclSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ShareAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sshares/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, shareId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ShareAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new acl for multiple share objects
 Required roles:  - can_write_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param shareId
 * @param objectType
 * @param body

@return CreateAcLsResultSchema
*/
func (pService *DefaultApiService) V1SharesShareIdAclObjectTypePut(ctx context.Context, shareId string, objectType string, body CreateShareAcLsSchema) (CreateAcLsResultSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CreateAcLsResultSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sshares/%v/acl/%v/", pService.Client.Cfg.BasePath, kSpec, shareId, objectType)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CreateAcLsResultSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a user acl for an object
 Required roles:  - can_delete_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param objectType
 * @param objectKey
*/
func (pService *DefaultApiService) V1UsersUserIdAclObjectTypeObjectKeyDelete(ctx context.Context, userId string, objectType string, objectKey string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, userId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService List of user permissions for an object
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param objectType
 * @param objectKey

@return UserAclSchema
*/
func (pService *DefaultApiService) V1UsersUserIdAclObjectTypeObjectKeyGet(ctx context.Context, userId string, objectType string, objectKey string) (UserAclSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, userId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns a user acl for an object
 Required roles:  - can_read_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param objectType
 * @param objectKey
 * @param permission

@return UserAclSchema
*/
func (pService *DefaultApiService) V1UsersUserIdAclObjectTypeObjectKeyPermissionGet(ctx context.Context, userId string, objectType string, objectKey string, permission string) (UserAclSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/acl/%v/%v/%v/", pService.Client.Cfg.BasePath, kSpec, userId, objectType, objectKey, permission)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update or create user acl for an object
 Required roles:  - can_write_acls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
 * @param objectType
 * @param objectKey
 * @param body

@return UserAclSchema
*/
func (pService *DefaultApiService) V1UsersUserIdAclObjectTypeObjectKeyPut(ctx context.Context, userId string, objectType string, objectKey string, body UserAclSchema) (UserAclSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UserAclSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%susers/%v/acl/%v/%v/", pService.Client.Cfg.BasePath, kSpec, userId, objectType, objectKey)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v UserAclSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
