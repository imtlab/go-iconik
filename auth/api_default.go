/*
 * iconik_auth
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package auth

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"fmt"

	"github.com/antihax/optional"
	"github.com/imtlab/iconik/shared"
)

const kSpec = "auth/v1/"

// Linger please
var (
	_ context.Context
)

type DefaultApiService shared.Service

/*
DefaultApiService Delete a particular app by id
 Required roles:  - can_delete_apps
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appId
*/
func (pService *DefaultApiService) V1AppsAppIdDelete(ctx context.Context, appId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/%v/", pService.Client.Cfg.BasePath, kSpec, appId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular app by id
 Required roles:  - can_read_apps
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appId

@return AppSchema

TY Note:
This differs from most other methods in that the "App-ID" header item is not set..
So (if ever I use this) I'll need to suppress adding the configured "App-ID" header item in pService.Client.PrepareRequest().
*/
func (pService *DefaultApiService) V1AppsAppIdGet(ctx context.Context, /*authToken string, */appId string) (AppSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AppSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/%v/", pService.Client.Cfg.BasePath, kSpec, appId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AppSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update app
 Required roles:  - can_write_apps
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appId
 * @param body

@return AppSchema
*/
func (pService *DefaultApiService) V1AppsAppIdPatch(ctx context.Context, appId string, body AppSchema) (AppSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AppSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/%v/", pService.Client.Cfg.BasePath, kSpec, appId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AppSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update app
 Required roles:  - can_write_apps
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appId
 * @param body

@return AppSchema
*/
func (pService *DefaultApiService) V1AppsAppIdPut(ctx context.Context, appId string, body AppSchema) (AppSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AppSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/%v/", pService.Client.Cfg.BasePath, kSpec, appId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AppSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Creates app token by id and returns itâ€™s data
 Required roles:  - can_read_apps
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param appId

@return TokenSchema
*/
func (pService *DefaultApiService) V1AppsAppIdTokenPost(ctx context.Context, appId string) (TokenSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TokenSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/%v/token/", pService.Client.Cfg.BasePath, kSpec, appId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TokenSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new token for the logged in user and store it for an external app

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return ExternalAuthRequestResponseSchema
*/
func (pService *DefaultApiService) V1AppsExternalAuthPost(ctx context.Context, body ExternalAuthRequestSchema) (ExternalAuthRequestResponseSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExternalAuthRequestResponseSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/external/auth/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ExternalAuthRequestResponseSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Gets a token requested by an external app

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param secret

@return ExternalAuthSchema
*/
func (pService *DefaultApiService) V1AppsExternalAuthSecretGet(ctx context.Context, secret string) (ExternalAuthSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExternalAuthSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/external/auth/%v/", pService.Client.Cfg.BasePath, kSpec, secret)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExternalAuthSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService List of apps
 Required roles:  - can_read_apps
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1AppsGetOpts - Optional Parameters:
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "LastId" (optional.String) -  ID of a last file set on previous page

@return AppsSchema
*/

type DefaultApiV1AppsGetOpts struct {
	PerPage optional.Int32
	LastId optional.String
}

func (pService *DefaultApiService) V1AppsGet(ctx context.Context, localVarOptionals *DefaultApiV1AppsGetOpts) (AppsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AppsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", shared.ParameterToString(localVarOptionals.LastId.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v AppsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete an approved instance of an app

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param approvedInstanceId
*/
func (pService *DefaultApiService) V1AppsInstanceApprovedInstanceIdDelete(ctx context.Context, approvedInstanceId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/instance/%v/", pService.Client.Cfg.BasePath, kSpec, approvedInstanceId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Gets an approved instance of an app

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param approvedInstanceId

@return ExternalAuthSchema
*/
func (pService *DefaultApiService) V1AppsInstanceApprovedInstanceIdGet(ctx context.Context, approvedInstanceId string) (ExternalAuthSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExternalAuthSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/instance/%v/", pService.Client.Cfg.BasePath, kSpec, approvedInstanceId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ExternalAuthSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new app instance

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return ApprovedAppInstanceSchema
*/
func (pService *DefaultApiService) V1AppsInstancePost(ctx context.Context, body ApprovedAppInstanceSchema) (ApprovedAppInstanceSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApprovedAppInstanceSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/instance/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ApprovedAppInstanceSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new app
 Required roles:  - can_write_apps
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return AppSchema
*/
func (pService *DefaultApiService) V1AppsPost(ctx context.Context, body AppSchema) (AppSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AppSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sapps/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v AppSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Login by ActiveDirectory
&lt;br/&gt;This function is not yet implemented.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return TokenSchema
*/
func (pService *DefaultApiService) V1AuthAdLoginPost(ctx context.Context, body interface{}) (TokenSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TokenSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/ad/login/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TokenSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Login by OAuth
&lt;br/&gt;This function is not yet implemented.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return TokenSchema
*/
func (pService *DefaultApiService) V1AuthOauthLoginPost(ctx context.Context, body interface{}) (TokenSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TokenSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/oauth/login/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TokenSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService SAML Assertion Consumer Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicId
*/
func (pService *DefaultApiService) V1AuthSamlAcsPublicIdPost(ctx context.Context, publicId string) (*http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/acs/%v/", pService.Client.Cfg.BasePath, kSpec, publicId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService SAML Assertion Consumer Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
 * @param identityProviderId
*/
func (pService *DefaultApiService) V1AuthSamlAcsSystemDomainIdIdentityProviderIdPost(ctx context.Context, systemDomainId string, identityProviderId string) (*http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/acs/%v/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Unbind domain from identity provider

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param domain
*/
func (pService *DefaultApiService) V1AuthSamlDomainsDomainDelete(ctx context.Context, domain string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/domains/%v/", pService.Client.Cfg.BasePath, kSpec, domain)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Bind domain to identity provider

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return DomainIdentityProviderMapSchema
*/
func (pService *DefaultApiService) V1AuthSamlDomainsPost(ctx context.Context, body DomainIdentityProviderMapSchema) (DomainIdentityProviderMapSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DomainIdentityProviderMapSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/domains/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v DomainIdentityProviderMapSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Convert an IdP EntityDescriptor XML into json suitable as a settings configuration.
&lt;br/&gt;Input should be a SAML EntityDescriptor XML.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return IdentityProviderSchema
*/
func (pService *DefaultApiService) V1AuthSamlIdpConvertPost(ctx context.Context, body IdentityProviderSchema) (IdentityProviderSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IdentityProviderSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/idp/convert/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	shared.GetHttpContentTypeAndHeaderAccept([]string{"application/xml"}, []string{}, localVarHeaderParams)

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v IdentityProviderSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Get list of identity providers
 Required roles:  - can_read_identity_providers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1AuthSamlIdpGetOpts - Optional Parameters:
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "LastId" (optional.String) -

@return IdentityProvidersSchema
*/

type DefaultApiV1AuthSamlIdpGetOpts struct {
	PerPage optional.Int32
	LastId optional.String
}

func (pService *DefaultApiService) V1AuthSamlIdpGet(ctx context.Context, localVarOptionals *DefaultApiV1AuthSamlIdpGetOpts) (IdentityProvidersSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IdentityProvidersSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/idp/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastId.IsSet() {
		localVarQueryParams.Add("last_id", shared.ParameterToString(localVarOptionals.LastId.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v IdentityProvidersSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular identity provider by id
 Required roles:  - can_delete_identity_providers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identityProviderId
*/
func (pService *DefaultApiService) V1AuthSamlIdpIdentityProviderIdDelete(ctx context.Context, identityProviderId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/idp/%v/", pService.Client.Cfg.BasePath, kSpec, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Get a particular identity provider by id
 Required roles:  - can_read_identity_providers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identityProviderId

@return IdentityProviderSchema
*/
func (pService *DefaultApiService) V1AuthSamlIdpIdentityProviderIdGet(ctx context.Context, identityProviderId string) (IdentityProviderSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IdentityProviderSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/idp/%v/", pService.Client.Cfg.BasePath, kSpec, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v IdentityProviderSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update a particular identity provider by id
 Required roles:  - can_write_identity_providers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identityProviderId
 * @param body

@return IdentityProviderSchema
*/
func (pService *DefaultApiService) V1AuthSamlIdpIdentityProviderIdPatch(ctx context.Context, identityProviderId string, body IdentityProviderSchema) (IdentityProviderSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IdentityProviderSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/idp/%v/", pService.Client.Cfg.BasePath, kSpec, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v IdentityProviderSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update a particular identity provider by id
 Required roles:  - can_write_identity_providers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identityProviderId
 * @param body

@return IdentityProviderSchema
*/
func (pService *DefaultApiService) V1AuthSamlIdpIdentityProviderIdPut(ctx context.Context, identityProviderId string, body IdentityProviderSchema) (IdentityProviderSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IdentityProviderSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/idp/%v/", pService.Client.Cfg.BasePath, kSpec, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v IdentityProviderSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new identity provider.
&lt;br/&gt;Input can either be an IdentityProviderSchema as json or a SAML&lt;br/&gt;EntityDescriptor XML. Required roles:  - can_write_identity_providers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return IdentityProviderSchema
*/
func (pService *DefaultApiService) V1AuthSamlIdpPost(ctx context.Context, body IdentityProviderSchema) (IdentityProviderSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IdentityProviderSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/idp/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	shared.GetHttpContentTypeAndHeaderAccept([]string{"application/json", "application/xml"}, []string{}, localVarHeaderParams)

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v IdentityProviderSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single sign-on url by domain

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param email

@return InlineResponse200
*/
func (pService *DefaultApiService) V1AuthSamlLoginEmailGet(ctx context.Context, email string) (InlineResponse200, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse200
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/login/%v/", pService.Client.Cfg.BasePath, kSpec, email)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse200
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single sign-on url by domain

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return InlineResponse200
*/
func (pService *DefaultApiService) V1AuthSamlLoginPost(ctx context.Context, body SamlLoginSchema) (InlineResponse200, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse200
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/login/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse200
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Initiate SAML Single logout

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicId

@return InlineResponse2001
*/
func (pService *DefaultApiService) V1AuthSamlLogoutPublicIdPost(ctx context.Context, publicId string) (InlineResponse2001, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2001
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/logout/%v/", pService.Client.Cfg.BasePath, kSpec, publicId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2001
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single Logout Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicId
*/
func (pService *DefaultApiService) V1AuthSamlMetadataPublicIdGet(ctx context.Context, publicId string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/metadata/%v/", pService.Client.Cfg.BasePath, kSpec, publicId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single Logout Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
 * @param identityProviderId
*/
func (pService *DefaultApiService) V1AuthSamlMetadataSystemDomainIdIdentityProviderIdGet(ctx context.Context, systemDomainId string, identityProviderId string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/metadata/%v/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single Logout Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicId
*/
func (pService *DefaultApiService) V1AuthSamlSloPublicIdGet(ctx context.Context, publicId string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/slo/%v/", pService.Client.Cfg.BasePath, kSpec, publicId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single Logout Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
 * @param identityProviderId
*/
func (pService *DefaultApiService) V1AuthSamlSloSystemDomainIdIdentityProviderIdGet(ctx context.Context, systemDomainId string, identityProviderId string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/slo/%v/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single sign-on Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicId
*/
func (pService *DefaultApiService) V1AuthSamlSsoPublicIdGet(ctx context.Context, publicId string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/sso/%v/", pService.Client.Cfg.BasePath, kSpec, publicId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService SAML Single sign-on Service

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
 * @param identityProviderId
*/
func (pService *DefaultApiService) V1AuthSamlSsoSystemDomainIdIdentityProviderIdGet(ctx context.Context, systemDomainId string, identityProviderId string) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/saml/sso/%v/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId, identityProviderId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Login by using email and password

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return TokenSchema
*/
func (pService *DefaultApiService) V1AuthSimpleLoginPost(ctx context.Context, body SimpleLoginSchema) (TokenSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TokenSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/simple/login/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v TokenSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Revoke token

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
*/
func (pService *DefaultApiService) V1AuthTokenDelete(ctx context.Context) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/token/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Check if auth token valid

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
*/
func (pService *DefaultApiService) V1AuthTokenGet(ctx context.Context) (*http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/token/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Refresh token

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return TokenSchema
*/
func (pService *DefaultApiService) V1AuthTokenPut(ctx context.Context) (TokenSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TokenSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sauth/token/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v TokenSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Receives email address and sends email to this address with link for resetting password

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
*/
func (pService *DefaultApiService) V1PasswordForgotPost(ctx context.Context, body ForgotPasswordSchema) (*http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%spassword/forgot/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Changes password to a new one

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param resetHash
 * @param body
*/
func (pService *DefaultApiService) V1PasswordResetResetHashPut(ctx context.Context, resetHash string, body ResetPasswordSchema) (*http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%spassword/reset/%v/", pService.Client.Cfg.BasePath, kSpec, resetHash)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Delete a referral_code

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code
*/
func (pService *DefaultApiService) V1ReferralCodesCodeDelete(ctx context.Context, code string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sreferral_codes/%v/", pService.Client.Cfg.BasePath, kSpec, code)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Get a referral_code

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code

@return ReferralCodeSchema
*/
func (pService *DefaultApiService) V1ReferralCodesCodeGet(ctx context.Context, code string) (ReferralCodeSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ReferralCodeSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sreferral_codes/%v/", pService.Client.Cfg.BasePath, kSpec, code)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ReferralCodeSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Get all referral_codes

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return ReferralCodesSchema
*/
func (pService *DefaultApiService) V1ReferralCodesGet(ctx context.Context) (ReferralCodesSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ReferralCodesSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sreferral_codes/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ReferralCodesSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new referral_code

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return ReferralCodeSchema
*/
func (pService *DefaultApiService) V1ReferralCodesPost(ctx context.Context, body ReferralCodeSchema) (ReferralCodeSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ReferralCodeSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sreferral_codes/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v ReferralCodeSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Returns list of countries

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return CountriesSchema
*/
func (pService *DefaultApiService) V1RegistrationsCountriesGet(ctx context.Context) (CountriesSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CountriesSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sregistrations/countries/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v CountriesSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new registration

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return RegistrationSchema
*/
func (pService *DefaultApiService) V1RegistrationsPost(ctx context.Context, body RegistrationSchema) (RegistrationSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RegistrationSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sregistrations/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v RegistrationSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Verify email address and create system domain from template is email address valid

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param emailHash

@return SystemDomainFromTemplateSchema
*/
func (pService *DefaultApiService) V1RegistrationsVerifyEmailHashPost(ctx context.Context, emailHash string) (SystemDomainFromTemplateSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainFromTemplateSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sregistrations/verify/%v/", pService.Client.Cfg.BasePath, kSpec, emailHash)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v SystemDomainFromTemplateSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService List of system domains

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1SystemDomainsGetOpts - Optional Parameters:
     * @param "Query" (optional.String) -  Query the name
     * @param "Statuses" (optional.String) -  Comma separated list of statuses to show

@return SystemDomainsSchema
*/

type DefaultApiV1SystemDomainsGetOpts struct {
	Query optional.String
	Statuses optional.String
}

func (pService *DefaultApiService) V1SystemDomainsGet(ctx context.Context, localVarOptionals *DefaultApiV1SystemDomainsGetOpts) (SystemDomainsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", shared.ParameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Statuses.IsSet() {
		localVarQueryParams.Add("statuses", shared.ParameterToString(localVarOptionals.Statuses.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SystemDomainsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new system domain

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return SystemDomainSchema
*/
func (pService *DefaultApiService) V1SystemDomainsPost(ctx context.Context, body SystemDomainSchema) (SystemDomainSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v SystemDomainSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new system domain from a referral code (That is associated to your domain)

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param referralCode
 * @param body

@return SystemDomainFromTemplateSchema
*/
func (pService *DefaultApiService) V1SystemDomainsReferralCodeReferralCodePost(ctx context.Context, referralCode string, body SystemDomainFromReferralCodeSchema) (SystemDomainFromTemplateSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainFromTemplateSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/referral_code/%v/", pService.Client.Cfg.BasePath, kSpec, referralCode)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v SystemDomainFromTemplateSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular system_domain by id

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
*/
func (pService *DefaultApiService) V1SystemDomainsSystemDomainIdDelete(ctx context.Context, systemDomainId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular system domain by id
 Required roles:  - can_read_system_domains
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId

@return SystemDomainSchema
*/
func (pService *DefaultApiService) V1SystemDomainsSystemDomainIdGet(ctx context.Context, systemDomainId string) (SystemDomainSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SystemDomainSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete system domain logo image.

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
*/
func (pService *DefaultApiService) V1SystemDomainsSystemDomainIdLogoDelete(ctx context.Context, systemDomainId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/%v/logo/", pService.Client.Cfg.BasePath, kSpec, systemDomainId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Upload system domain logo image.

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
 * @param logo

@return InlineResponse201
*/
func (pService *DefaultApiService) V1SystemDomainsSystemDomainIdLogoPost(ctx context.Context, systemDomainId string, logo string) (InlineResponse201, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse201
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/%v/logo/", pService.Client.Cfg.BasePath, kSpec, systemDomainId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	localVarFormParams.Add("logo", shared.ParameterToString(logo, ""))
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v InlineResponse201
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update system domain

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
 * @param body

@return SystemDomainSchema
*/
func (pService *DefaultApiService) V1SystemDomainsSystemDomainIdPatch(ctx context.Context, systemDomainId string, body SystemDomainSchema) (SystemDomainSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SystemDomainSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update system domain

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainId
 * @param body

@return SystemDomainSchema
*/
func (pService *DefaultApiService) V1SystemDomainsSystemDomainIdPut(ctx context.Context, systemDomainId string, body SystemDomainSchema) (SystemDomainSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/%v/", pService.Client.Cfg.BasePath, kSpec, systemDomainId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SystemDomainSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService List of system domain templates

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return SystemDomainsSchema
*/
func (pService *DefaultApiService) V1SystemDomainsTemplatesGet(ctx context.Context) (SystemDomainsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SystemDomainsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%ssystem_domains/templates/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v SystemDomainsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
