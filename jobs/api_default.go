/*
 * iconik_jobs
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package jobs

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"fmt"

	"github.com/antihax/optional"
	"github.com/imtlab/iconik/shared"
)

const kSpec = "jobs/v1/"

// Linger please
var (
	_ context.Context
)

type DefaultApiService shared.Service

/*
DefaultApiService Delete multiple jobs by ids list
 Required roles:  - can_delete_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
*/
func (pService *DefaultApiService) V1JobsDelete(ctx context.Context, body JobsBulkDeleteSchema) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Get list of jobs
 Required roles:  - can_read_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DefaultApiV1JobsGetOpts - Optional Parameters:
     * @param "Facets" (optional.Bool) -  If facets should be returned
     * @param "Page" (optional.Int32) -  Which page number to fetch
     * @param "PerPage" (optional.Int32) -  The number of items for each page
     * @param "Sort" (optional.String) -  A comma separated list of fieldnames with order. For example - first_name,asc;last_name,desc
     * @param "Type_" (optional.String) -  Filter by type
     * @param "ObjectType" (optional.String) -  Filter by object_type
     * @param "ParentId" (optional.String) -  Filter by parent_id
     * @param "ObjectId" (optional.String) -  Filter by object_id
     * @param "Status" (optional.String) -  Filter by status
     * @param "CreatedBy" (optional.String) -  Filter by created_by
     * @param "DateCreated" (optional.String) -  Filter by date_created. Can either be a single ISO8601 timestamp or two timestamps separated by a semicolon &#x60;;&#x60;. The timestamp can also be expressed as number of milliseconds since Jan 1 1970 (epoch). Either timestamp can also be replaced with an asterisk &#x60;*&#x60; to make the query open ended. For example: 2018-01-01T10:00:00Z;2018-01-01T15:00:00Z
     * @param "DateModified" (optional.String) -  Filter by date_modified Can either be a single ISO8601 timestamp or two timestamps separated by a semicolon &#x60;;&#x60;. The timestamp can also be expressed as number of milliseconds since Jan 1 1970 (epoch). Either timestamp can also be replaced with an asterisk &#x60;*&#x60; to make the query open ended. For example: *;1544450400
     * @param "Query" (optional.String) -  Filter by any of the above with wildcard support
     * @param "Ids" (optional.String) -  Filter list of id:s (comma separated)

@return JobsSchema
*/

type DefaultApiV1JobsGetOpts struct {
	Facets optional.Bool
	Page optional.Int32
	PerPage optional.Int32
	Sort optional.String
	Type_ optional.String
	ObjectType optional.String
	ParentId optional.String
	ObjectId optional.String
	Status optional.String
	CreatedBy optional.String
	DateCreated optional.String
	DateModified optional.String
	Query optional.String
	Ids optional.String
}

func (pService *DefaultApiService) V1JobsGet(ctx context.Context, localVarOptionals *DefaultApiV1JobsGetOpts) (JobsSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobsSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Facets.IsSet() {
		localVarQueryParams.Add("facets", shared.ParameterToString(localVarOptionals.Facets.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", shared.ParameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("per_page", shared.ParameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", shared.ParameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", shared.ParameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectType.IsSet() {
		localVarQueryParams.Add("object_type", shared.ParameterToString(localVarOptionals.ObjectType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentId.IsSet() {
		localVarQueryParams.Add("parent_id", shared.ParameterToString(localVarOptionals.ParentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectId.IsSet() {
		localVarQueryParams.Add("object_id", shared.ParameterToString(localVarOptionals.ObjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", shared.ParameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedBy.IsSet() {
		localVarQueryParams.Add("created_by", shared.ParameterToString(localVarOptionals.CreatedBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateCreated.IsSet() {
		localVarQueryParams.Add("date_created", shared.ParameterToString(localVarOptionals.DateCreated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateModified.IsSet() {
		localVarQueryParams.Add("date_modified", shared.ParameterToString(localVarOptionals.DateModified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", shared.ParameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ids.IsSet() {
		localVarQueryParams.Add("ids", shared.ParameterToString(localVarOptionals.Ids.Value(), ""))
	}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobsSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Delete a particular job by id
 Required roles:  - can_delete_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
*/
func (pService *DefaultApiService) V1JobsJobIdDelete(ctx context.Context, jobId string) (*http.Response, error) {
	const localVarHttpMethod = "DELETE"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/%v/", pService.Client.Cfg.BasePath, kSpec, jobId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Returns a particular job by id
 Required roles:  - can_read_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId

@return JobSchema
*/
func (pService *DefaultApiService) V1JobsJobIdGet(ctx context.Context, jobId string) (JobSchema, *http.Response, error) {
	const localVarHttpMethod = "GET"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/%v/", pService.Client.Cfg.BasePath, kSpec, jobId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update job
 Required roles:  - can_write_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
 * @param body

@return JobSchema
*/
func (pService *DefaultApiService) V1JobsJobIdPatch(ctx context.Context, jobId string, body JobSchema) (JobSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/%v/", pService.Client.Cfg.BasePath, kSpec, jobId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update job
 Required roles:  - can_write_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
 * @param body

@return JobSchema
*/
func (pService *DefaultApiService) V1JobsJobIdPut(ctx context.Context, jobId string, body JobSchema) (JobSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/%v/", pService.Client.Cfg.BasePath, kSpec, jobId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Reindex job
 Required roles:  - can_write_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
 * @param body
*/
func (pService *DefaultApiService) V1JobsJobIdReindexPost(ctx context.Context, jobId string, body ReindexJobSchema) (*http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/%v/reindex/", pService.Client.Cfg.BasePath, kSpec, jobId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Update job step
 Required roles:  - can_write_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainID
 * @param jobId
 * @param jobStepId
 * @param body

@return JobSchema
*/
func (pService *DefaultApiService) V1JobsJobIdStepsJobStepIdPatch(ctx context.Context, systemDomainID string, jobId string, jobStepId string, body JobStepSchema) (JobSchema, *http.Response, error) {
	const localVarHttpMethod = "PATCH"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/%v/steps/%v/", pService.Client.Cfg.BasePath, kSpec, jobId, jobStepId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	localVarHeaderParams["System-Domain-ID"] = shared.ParameterToString(systemDomainID, "")

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Update job step
 Required roles:  - can_write_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param systemDomainID
 * @param jobId
 * @param jobStepId
 * @param body

@return JobSchema
*/
func (pService *DefaultApiService) V1JobsJobIdStepsJobStepIdPut(ctx context.Context, systemDomainID string, jobId string, jobStepId string, body JobStepSchema) (JobSchema, *http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/%v/steps/%v/", pService.Client.Cfg.BasePath, kSpec, jobId, jobStepId)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	localVarHeaderParams["System-Domain-ID"] = shared.ParameterToString(systemDomainID, "")

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v JobSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Create a new job

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body

@return JobSchema
*/
func (pService *DefaultApiService) V1JobsPost(ctx context.Context, body JobSchema) (JobSchema, *http.Response, error) {
	const localVarHttpMethod = "POST"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobSchema
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = pService.Client.Decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 201 {
			var v JobSchema
			err = pService.Client.Decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.ErrorMsg = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.Model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
DefaultApiService Change jobs priority
 Required roles:  - can_write_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
*/
func (pService *DefaultApiService) V1JobsPriorityPut(ctx context.Context, body JobsPrioritySchema) (*http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/priority/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
DefaultApiService Change jobs state
 Required roles:  - can_write_jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
*/
func (pService *DefaultApiService) V1JobsStatePut(ctx context.Context, body JobsStateSchema) (*http.Response, error) {
	const localVarHttpMethod = "PUT"

	var (
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := fmt.Sprintf("%s%sjobs/state/", pService.Client.Cfg.BasePath, kSpec)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

//	shared.GetHttpContentTypeAndHeaderAccept([]string{}, []string{}, localVarHeaderParams)	//	does nothing

	// body params
	localVarPostBody = &body
	r, err := pService.Client.PrepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := pService.Client.CallAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := shared.GenericSwaggerError{
			Body: localVarBody,
			ErrorMsg: localVarHttpResponse.Status,
		}

		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
